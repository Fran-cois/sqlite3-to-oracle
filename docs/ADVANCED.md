# Utilisation Avancée de SQLite vers Oracle

Ce document fournit des instructions pour une utilisation avancée de l'outil SQLite vers Oracle.

## Table des matières

1. [Mappages de Types](#mappages-de-types)
2. [Ajustements des Clés Primaires](#ajustements-des-clés-primaires)
3. [Importation Sélective](#importation-sélective)
4. [Performances](#performances)
5. [Traitement des Erreurs](#traitement-des-erreurs)

## Mappages de Types

### Mappages de Types par Défaut

| Type SQLite      | Type Oracle       | Commentaires                                  |
|------------------|-------------------|----------------------------------------------|
| INTEGER          | NUMBER            | Type numérique standard                      |
| INT              | NUMBER            | Alias pour INTEGER                           |
| REAL             | NUMBER(38,10)     | Pour les nombres à virgule flottante         |
| FLOAT            | NUMBER(38,10)     | Pour les nombres à virgule flottante         |
| TEXT             | VARCHAR2(4000)    | Pour les chaînes jusqu'à 4000 caractères     |
| CHAR(n)          | CHAR(n)           | Pour les chaînes de longueur fixe            |
| VARCHAR(n)       | VARCHAR2(n)       | Pour les chaînes de longueur variable        |
| BLOB             | BLOB              | Pour les données binaires                    |
| DATETIME         | TIMESTAMP         | Pour les dates et heures                     |
| BOOLEAN          | NUMBER(1)         | 0 = false, 1 = true                          |

### Gestion des Types Spécifiques

#### Colonnes numériques avec précision

SQLite n'a pas de type numérique avec précision explicite. Par défaut, les nombres avec décimales sont convertis en `NUMBER(38,10)` pour Oracle. Utilisez l'option `--use-varchar` pour les gérer en tant que chaînes si nécessaire.

#### Texte long

Les chaînes très longues (>4000 caractères) sont tronquées par défaut lors de l'utilisation de VARCHAR2. Pour gérer des textes longs, l'outil les convertit automatiquement en CLOB.

#### Valeurs NULL

Les valeurs NULL de SQLite sont directement mappées vers NULL dans Oracle.

## Ajustements des Clés Primaires

Par défaut, l'outil tente de préserver les contraintes de clé primaire. Pour les colonnes INTEGER PRIMARY KEY AUTOINCREMENT dans SQLite, elles sont converties en `NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY` dans Oracle.

### Comportement de création des identités

Pour les tables sans clé primaire explicite, l'outil cherche une colonne potentielle qui pourrait servir de clé primaire en utilisant les règles suivantes:

1. Le nom de colonne est "ID"
2. Le nom de colonne est le nom de la table suivi de "_ID"
3. Le nom de colonne se termine par "_ID"

## Importation Sélective

### Importer uniquement le schéma (sans données)

```bash
sqlite3-to-oracle --sqlite_db ma_base.sqlite --schema-only
```

### Importer uniquement la structure relationnelle

Pour préserver uniquement le squelette de la base de données (tables avec clés primaires et étrangères), utilisez:

```bash
sqlite3-to-oracle --sqlite_db ma_base.sqlite --only-fk-keys
```

### Importer des tables spécifiques

Si vous avez besoin d'importer uniquement certaines tables spécifiques après une importation initiale ou un échec, utilisez:

```bash
reload-missing-tables --sqlite-path ma_base.sqlite --table-name MA_TABLE
```

## Performances

### Optimisations pour les grosses tables

L'outil inclut des optimisations spéciales pour les tables volumineuses:

1. **Taille de lot adaptative**: Le nombre de lignes traitées par lot est ajusté en fonction du nombre de colonnes
2. **Chargement parallèle**: Si votre version d'Oracle le supporte (12.2+), l'option de chargement parallèle est activée automatiquement
3. **Log d'erreurs**: Pour les insertions en masse, les erreurs sont capturées dans une table de log séparée sans interrompre le processus

### Conseils pour améliorer les performances

- Pour les tables avec de nombreuses colonnes décimales problématiques, utilisez `--use-varchar`
- Essayez différentes tailles de lot (via l'API programmatique) pour déterminer la valeur optimale pour votre cas
- Pour les bases très volumineuses, importez d'abord le schéma puis les données par table

## Traitement des Erreurs

### Erreurs Courantes et Solutions

| Erreur                               | Cause Possible                               | Solution                                     |
|--------------------------------------|----------------------------------------------|----------------------------------------------|
| ORA-00972 (identifier too long)      | Nom de table/colonne/contrainte trop long    | Les identifiants sont automatiquement tronqués |
| ORA-01438 (value larger than allowed)| Valeur trop grande pour le type Oracle      | Utiliser `--use-varchar`                     |
| ORA-01722 (invalid number)           | Chaîne dans colonne numérique               | Utiliser `--use-varchar`                     |
| ORA-00001 (unique constraint violated)| Violation de contrainte d'unicité           | Vérifier les données pour les doublons       |

### Stratégie de reprise

En cas d'erreur pendant l'importation, l'outil peut réessayer automatiquement avec différentes stratégies:

1. Retenter avec des lots plus petits
2. Passer au mode ligne par ligne
3. Simplifier la structure de table
4. Enregistrer les erreurs dans une table de log

Pour réimporter les tables qui ont échoué:

```bash
sqlite3-to-oracle --sqlite_db ma_base.sqlite --retry
```

ou

```bash
reload-missing-tables --sqlite-path ma_base.sqlite --report-file rapport_validation.txt
```
