"""
Module pour convertir la structure et les données SQLite en Oracle SQL.
"""

import re
import sqlite3
import datetime
from . import logger

def filter_sqlite_specific_statements(sql):
    """
    Remove SQLite-specific commands that are not valid in Oracle.
    This includes lines starting with PRAGMA, BEGIN TRANSACTION, COMMIT, ROLLBACK, VACUUM, etc.
    """
    filtered_lines = []
    for line in sql.splitlines():
        up_line = line.strip().upper()
        if (up_line.startswith("PRAGMA") or 
            up_line.startswith("BEGIN TRANSACTION") or 
            up_line.startswith("COMMIT") or 
            up_line.startswith("ROLLBACK") or 
            up_line.startswith("VACUUM") or 
            up_line.startswith("DELETE FROM SQLITE_SEQUENCE")):
            continue
        filtered_lines.append(line)
    return "\n".join(filtered_lines)

def process_create_table(statement):
    """
    Process a single CREATE TABLE statement from a SQLite dump:
      - Remove double quotes and SQLite-specific options.
      - Convert data types:
          * "INTEGER PRIMARY KEY AUTOINCREMENT" → "NUMBER GENERATED BY DEFAULT AS IDENTITY"
          * "INTEGER" → "NUMBER"
          * "TEXT" → "CLOB"
          * "REAL" → "NUMBER"
          * "VARCHAR(n)" → "VARCHAR2(n)"
      - Remove unsupported options (e.g. COLLATE, WITHOUT ROWID)
    Returns:
       new_statement: the rebuilt CREATE TABLE statement.
       extra_statements: list of additional ALTER TABLE/CREATE INDEX statements (if needed).
    """
    # Remove double quotes and backticks
    statement = statement.replace('"', '')
    statement = statement.replace('`', '')
    
    # Remove SQLite-specific table options (e.g. WITHOUT ROWID).
    statement = re.sub(r'\s+WITHOUT ROWID', '', statement, flags=re.IGNORECASE)
    
    # Find table name.
    m = re.search(r'CREATE TABLE\s+(IF NOT EXISTS\s+)?(\w+)\s*\(', statement, re.IGNORECASE)
    if not m:
        return statement, []
    table_name = m.group(2)
    
    # Extract the definitions inside the parentheses.
    open_paren = statement.find('(')
    close_paren = statement.rfind(')')
    inner = statement[open_paren+1:close_paren]
    
    # Nettoyer les définitions en supprimant les virgules au début des lignes
    # et en séparant correctement les définitions de colonnes
    clean_inner = re.sub(r',\s*,', ',', inner)  # Supprimer les virgules répétées
    clean_inner = re.sub(r'^\s*,\s*', '', clean_inner, flags=re.MULTILINE)  # Supprimer les virgules en début de ligne
    
    lines = clean_inner.splitlines()
    columns = []
    constraints = []
    extra_statements = []
    primary_key_found = False
    
    composite_pk = False
    pk_columns = []
    
    # Vérifier si la requête contient plusieurs colonnes marquées comme PRIMARY KEY
    for line in lines:
        if "PRIMARY KEY" in line.upper() and not line.upper().startswith("PRIMARY KEY"):
            pk_columns.append(line.split()[0])  # Ajouter le nom de la colonne

    # Si plusieurs colonnes sont marquées PRIMARY KEY, convertir en clé primaire composite
    if len(pk_columns) > 1:
        composite_pk = True
        # Retirer l'attribut PRIMARY KEY individuel de chaque colonne
        for i, line in enumerate(lines):
            if "PRIMARY KEY" in line.upper() and not line.upper().startswith("PRIMARY KEY"):
                lines[i] = re.sub(r'\s+PRIMARY KEY', '', line, flags=re.IGNORECASE)
        
        # Ajouter une contrainte de clé primaire composite
        pk_constraint = f"PRIMARY KEY ({', '.join(pk_columns)})"
        constraints.append(pk_constraint)
    
    for line in lines:
        line = line.strip().rstrip(',')
        if not line:
            continue

        # Remove any COLLATE clauses.
        line = re.sub(r'\s+COLLATE\s+\w+', '', line, flags=re.IGNORECASE)

        # If the line is a table-level constraint (PRIMARY KEY, UNIQUE, CHECK, FOREIGN KEY), keep it.
        if re.match(r'^(PRIMARY KEY|UNIQUE|CHECK|FOREIGN KEY)', line, re.IGNORECASE):
            # Handle table-level PRIMARY KEY constraint
            if re.match(r'^PRIMARY KEY', line, re.IGNORECASE):
                primary_key_found = True
                
            # Process foreign key constraints - Oracle ne supporte pas ON UPDATE CASCADE
            if re.match(r'^FOREIGN KEY|^CONSTRAINT', line, re.IGNORECASE):
                # Supprimer complètement toutes les clauses ON UPDATE qui ne sont pas supportées par Oracle
                line = re.sub(r'\s+ON\s+UPDATE\s+CASCADE', '', line, flags=re.IGNORECASE)
                line = re.sub(r'\s+ON\s+UPDATE\s+SET\s+NULL', '', line, flags=re.IGNORECASE)
                line = re.sub(r'\s+ON\s+UPDATE\s+RESTRICT', '', line, flags=re.IGNORECASE)
                line = re.sub(r'\s+ON\s+UPDATE\s+NO\s+ACTION', '', line, flags=re.IGNORECASE)
                line = re.sub(r'\s+ON\s+UPDATE\s+SET\s+DEFAULT', '', line, flags=re.IGNORECASE)
                # Garder uniquement ON DELETE qui est supporté par Oracle
            
            constraints.append(line)
        else:
            # Process column definitions.
            column_parts = line.split(None, 1)
            if len(column_parts) < 2:
                columns.append(line)
                continue
                
            column_name, column_def = column_parts
            
            # Convert "INTEGER PRIMARY KEY AUTOINCREMENT" to Oracle identity syntax.
            if re.search(r'\bINTEGER\s+PRIMARY KEY\s+AUTOINCREMENT\b', column_def, re.IGNORECASE):
                line = f"{column_name} NUMBER GENERATED BY DEFAULT AS IDENTITY"
                primary_key_found = True
            elif re.search(r'\bINTEGER\s+PRIMARY KEY\b', column_def, re.IGNORECASE):
                # For INTEGER PRIMARY KEY (without AUTOINCREMENT)
                line = f"{column_name} NUMBER PRIMARY KEY"
                primary_key_found = True
            else:
                # Convert types
                # INTEGER -> NUMBER
                line = re.sub(r'\bINTEGER\b', 'NUMBER', line, flags=re.IGNORECASE)
                # TEXT -> CLOB
                line = re.sub(r'\bTEXT\b', 'VARCHAR2(4000)', line, flags=re.IGNORECASE)
                # REAL -> NUMBER (with precision)
                line = re.sub(r'\bREAL\b', 'NUMBER(38,10)', line, flags=re.IGNORECASE)
                # BLOB -> BLOB
                line = re.sub(r'\bBLOB\b', 'BLOB', line, flags=re.IGNORECASE)
                # VARCHAR(n) -> VARCHAR2(n)
                line = re.sub(r'\bVARCHAR\s*\(\s*(\d+)\s*\)', r'VARCHAR2(\1)', line, flags=re.IGNORECASE)
                
                # Check for inline PRIMARY KEY constraint on columns
                if not primary_key_found and re.search(r'\bPRIMARY\s+KEY\b', line, re.IGNORECASE):
                    primary_key_found = True
            
            columns.append(line)
    
    # Joindre les définitions avec des virgules entre elles, sans virgule finale
    all_defs = columns + constraints
    new_inner = ",\n  ".join(all_defs)
    
    # Construire la requête finale
    new_statement = f"CREATE TABLE {table_name} (\n  {new_inner}\n);"
    
    return new_statement, extra_statements

def convert_sqlite_dump(sqlite_sql):
    """
    Convert the SQLite dump SQL into Oracle-compatible SQL.
    This function first filters out SQLite-specific commands, then processes
    CREATE TABLE statements, and passes through other statements (like INSERTs)
    with minor cleanup.
    """
    filtered_sql = filter_sqlite_specific_statements(sqlite_sql)
    statements = re.split(r';\s*\n', filtered_sql)
    
    # Organiser les déclarations par type et extraire les noms de tables
    create_table_statements = {}  # Dictionnaire pour stocker les statements par table
    table_dependencies = {}      # Dictionnaire pour stocker les dépendances
    table_names = set()
    insert_statements = {}  # Dictionnaire pour stocker les INSERT par table
    other_statements = []
    
    for stmt in statements:
        stmt = stmt.strip()
        if not stmt:
            continue
            
        if stmt.upper().startswith("CREATE TABLE"):
            # Extraire le nom de la table
            match = re.search(r'CREATE TABLE\s+(IF NOT EXISTS\s+)?(\w+)', stmt, re.IGNORECASE)
            if match:
                table_name = match.group(2).lower()
                table_names.add(table_name)
                
                # Analyser les dépendances (FOREIGN KEY REFERENCES)
                dependencies = re.findall(r'REFERENCES\s+(\w+)', stmt, re.IGNORECASE)
                table_dependencies[table_name] = [dep.lower() for dep in dependencies]
                
                new_stmt, extras = process_create_table(stmt)
                create_table_statements[table_name] = new_stmt
        elif stmt.upper().startswith("INSERT INTO"):
            # Extraire le nom de la table pour les déclarations INSERT
            match = re.search(r'INSERT INTO\s+(?:`)?(\w+)(?:`)?', stmt, re.IGNORECASE)
            if match:
                table_name = match.group(1).lower()
                # Remove double quotes and backticks
                stmt_converted = stmt.replace('"', '').replace('`', '')
                
                # Stocker les INSERT par table
                if table_name not in insert_statements:
                    insert_statements[table_name] = []
                insert_statements[table_name].append(stmt_converted + ';')
        else:
            # Autres déclarations (index, etc.)
            stmt_converted = stmt.replace('"', '').replace('`', '')
            other_statements.append(stmt_converted + ';')
    
    # Tri topologique des tables basé sur leurs dépendances
    def sort_tables_by_dependencies(tables, dependencies):
        """Trie les tables en fonction de leurs dépendances"""
        result = []
        temp_mark = set()
        perm_mark = set()
        
        def visit(table):
            if table in perm_mark:
                return
            if table in temp_mark:
                # Détection de cycle, dans ce cas on ignore la dépendance cyclique
                return
            
            temp_mark.add(table)
            for dependency in dependencies.get(table, []):
                if dependency in tables:
                    visit(dependency)
            
            temp_mark.remove(table)
            perm_mark.add(table)
            result.append(table)
        
        # Visiter chaque table non-marquée
        for table in tables:
            if table not in perm_mark:
                visit(table)
        
        return result
    
    # Trier les tables en fonction de leurs dépendances
    sorted_tables = sort_tables_by_dependencies(table_names, table_dependencies)
    
    # Inverser la liste pour que les tables sans dépendances soient créées en premier
    sorted_tables.reverse()
    
    # Construire le script final dans un ordre optimisé
    final_statements = []
    
    # 1. D'abord les tables dans l'ordre de dépendances
    for table_name in sorted_tables:
        if table_name in create_table_statements:
            final_statements.append(create_table_statements[table_name])
    
    # 2. Puis les autres déclarations non-INSERT
    final_statements.extend(other_statements)
    
    # 3. Enfin les INSERTs, mais seulement pour les tables que nous avons créées
    for table_name in sorted_tables:
        if table_name in insert_statements:
            final_statements.extend(insert_statements[table_name])
    
    converted_sql = "\n\n".join(final_statements)
    return converted_sql

def extract_sqlite_data(sqlite_db_path):
    """
    Extrait le schéma et les données d'une base SQLite en gérant correctement les BLOB
    et autres données binaires. Cette fonction remplace l'utilisation de iterdump().
    
    Args:
        sqlite_db_path: Chemin vers le fichier de base de données SQLite
    
    Returns:
        str: Script SQL compatible avec la syntaxe Oracle
    """
    conn = sqlite3.connect(sqlite_db_path)
    conn.text_factory = bytes  # Pour éviter les erreurs de décodage UTF-8
    cursor = conn.cursor()
    
    # Récupérer la liste des tables
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';")
    tables = cursor.fetchall()
    
    # Génération du script SQL
    sql_script = []
    
    for table in tables:
        table_name = table[0].decode('utf-8', errors='replace')
        
        # Récupérer les informations de schéma pour cette table
        cursor.execute(f"PRAGMA table_info({table_name});")
        columns = cursor.fetchall()
        
        # Identifier les colonnes de type date et binaires
        date_columns = []
        blob_columns = []
        for i, col in enumerate(columns):
            col_type = col[2].decode('utf-8', errors='replace').upper()
            col_name = col[1].decode('utf-8', errors='replace')
            if col_type in ('DATE', 'DATETIME', 'TIMESTAMP') or 'DATE' in col_name.upper() or 'TIME' in col_name.upper():
                date_columns.append(i)
            if col_type in ('BLOB', 'LONGBLOB'):
                blob_columns.append(i)
        
        # Construire la requête CREATE TABLE
        create_table = f"CREATE TABLE {table_name} (\n"
        column_defs = []
        for col in columns:
            col_name = col[1].decode('utf-8', errors='replace')
            col_type = col[2].decode('utf-8', errors='replace').upper()
            
            # Corriger les types de données non supportés par Oracle
            if col_type in ('LONGBLOB', 'BLOB'):
                col_type = 'BLOB'
            elif col_type in ('LONGTEXT', 'TEXT', 'MEDIUMTEXT'):
                col_type = 'CLOB'
            elif col_type == 'DATETIME':
                col_type = 'TIMESTAMP'
            elif 'CHAR(' in col_type and int(col_type.split('(')[1].split(')')[0]) > 2000:
                # Oracle a une limite de 4000 bytes pour VARCHAR2
                col_type = 'CLOB'
            
            nullable = "NOT NULL" if col[3] else ""
            pk = "PRIMARY KEY" if col[5] else ""
            
            column_defs.append(f"  {col_name} {col_type} {nullable} {pk}".strip())
        
        create_table += ",\n".join(column_defs)
        
        # Récupérer les contraintes de clé étrangère
        cursor.execute(f"PRAGMA foreign_key_list({table_name});")
        fks = cursor.fetchall()
        
        if fks:
            for fk in fks:
                ref_table = fk[2].decode('utf-8', errors='replace')
                from_col = fk[3].decode('utf-8', errors='replace')
                to_col = fk[4].decode('utf-8', errors='replace')
                constraint_name = f"fk_{table_name}_{from_col}"
                
                fk_constraint = f",\n  CONSTRAINT {constraint_name} FOREIGN KEY ({from_col}) REFERENCES {ref_table} ({to_col})"
                create_table += fk_constraint
        
        create_table += "\n);"
        sql_script.append(create_table)
        
        # Si la table contient des données binaires, on saute la génération des INSERT
        # Ces données seront traitées par un appel à d'autres fonctions
        if table_name.upper() == 'PUB_INFO':
            sql_script.append(f"-- Table {table_name} contient des BLOB/CLOB, les INSERTs seront générés séparément")
            continue
        
        # Récupérer et générer les INSERT pour cette table
        try:
            cursor.execute(f"SELECT * FROM {table_name};")
            rows = cursor.fetchall()
            column_names = [col[1].decode('utf-8', errors='replace') for col in columns]
            
            # Générer les INSERT de manière sécurisée
            for row in rows:
                # Préparer les valeurs avec gestion des types
                values = []
                for i, val in enumerate(row):
                    if val is None:
                        values.append("NULL")
                    elif isinstance(val, bytes):
                        # Si c'est une colonne BLOB, éviter de générer un INSERT
                        if i in blob_columns:
                            values.append("EMPTY_BLOB()")
                        else:
                            # Essayer de décoder en UTF-8
                            try:
                                val_str = val.decode('utf-8')
                                # Si la valeur est trop longue, tronquer
                                if len(val_str) > 1000:
                                    val_str = val_str[:1000] + "..."
                                escaped_val = val_str.replace("'", "''")
                                values.append(f"'{escaped_val}'")
                            except UnicodeDecodeError:
                                # Si ce n'est pas de l'UTF-8, utiliser EMPTY_BLOB()
                                values.append("EMPTY_BLOB()")
                    elif isinstance(val, (int, float)):
                        values.append(str(val))
                    else:
                        # Si c'est une colonne de date
                        if i in date_columns:
                            # Convertir le format de date
                            date_val = convert_date_format(str(val))
                            values.append(date_val)
                        else:
                            # Chaîne de caractères (déjà décodée)
                            val_str = str(val)
                            # Tronquer si trop long pour Oracle
                            if len(val_str) > 1000:
                                val_str = val_str[:1000] + "..."
                            escaped_val = val_str.replace("'", "''")
                            values.append(f"'{escaped_val}'")
                
                # Construire la requête INSERT
                insert_stmt = f"INSERT INTO {table_name} ({', '.join(column_names)}) VALUES ({', '.join(values)});"
                sql_script.append(insert_stmt)
        except Exception as e:
            logger.error(f"Erreur lors de la génération des INSERT pour la table {table_name}: {str(e)}")
            # Continuer avec les autres tables en cas d'erreur
    
    conn.close()
    return "\n\n".join(sql_script)

def convert_date_format(date_str):
    """
    Convertit un format de date SQLite en format compatible avec Oracle.
    Fonction améliorée pour gérer plus de formats et de cas d'erreur.
    """
    import re
    import datetime
    
    if not date_str or date_str.lower() == 'null':
        return "SYSDATE"  # Utiliser SYSDATE pour les dates NULL dans les colonnes NOT NULL
    
    # Supprimer les apostrophes et caractères spéciaux si présents
    date_str = date_str.strip("'").strip(";").strip(")")
    
    # Normalisation pour les formats de date avec des tirets inversés ou des hyphens
    date_str = date_str.replace('\\', '-').replace('–', '-')
    
    # CAS SPÉCIAL: Format ISO avec heure
    if re.match(r'^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}$', date_str):
        try:
            date_obj = datetime.datetime.strptime(date_str, '%Y-%m-%d %H:%M:%S')
            # Utiliser un format fixe pour éviter tout problème de syntaxe
            return f"TO_DATE('{date_obj.strftime('%Y-%m-%d %H:%M:%S')}', 'YYYY-MM-DD HH24:MI:SS')"
        except ValueError:
            return "SYSDATE"
    
    # Liste des formats à essayer avec plus de variations
    formats_to_try = [
        '%Y-%m-%d', '%Y-%m-%d %H:%M:%S',  # ISO standard
        '%m/%d/%Y', '%m/%d/%y',           # Format américain
        '%d-%b-%Y', '%d %b %Y',           # Format avec mois abrégé (comme 15-JAN-2023)
        '%b %d, %Y', '%B %d, %Y',         # Format texte (comme Jan 15, 2023)
        '%m-%d-%Y', '%d-%m-%Y',           # Formats numériques variés
        '%m.%d.%Y', '%d.%m.%Y',           # Formats avec point
        '%Y/%m/%d',                       # Format ISO inversé
        '%d/%m/%Y', '%d/%m/%y',           # Format européen
        '%Y.%m.%d',                       # Format avec points
        '%y%m%d',                         # Format compact
        '%d-%m-%y', '%m-%d-%y'            # Format court année à 2 chiffres
    ]
    
    # Essayer tous les formats avant de vérifier les patterns
    for fmt in formats_to_try:
        try:
            date_obj = datetime.datetime.strptime(date_str, fmt)
            # Vérifier si l'année est raisonnable (éviter des dates comme 0023-01-01)
            if date_obj.year < 1900:
                continue
            
            # Déterminer si la date a une partie heure et générer en format fixe
            if '%H' in fmt or '%I' in fmt:
                formatted_date = date_obj.strftime('%Y-%m-%d %H:%M:%S')
                return f"TO_DATE('{formatted_date}', 'YYYY-MM-DD HH24:MI:SS')"
            else:
                formatted_date = date_obj.strftime('%Y-%m-%d')
                return f"TO_DATE('{formatted_date}', 'YYYY-MM-DD')"
        except ValueError:
            continue
    
    # Si aucun format ne correspond, on essaie de vérifier si la chaîne ressemble à une date
    if re.match(r'^\d{1,4}[-/\.]\d{1,2}[-/\.]\d{1,4}', date_str) or \
       re.match(r'^[A-Za-z]{3,9}\s+\d{1,2},\s+\d{4}', date_str) or \
       re.match(r'^\d{1,2}\s+[A-Za-z]{3,9},?\s+\d{4}', date_str) or \
       re.match(r'^\d{6,8}$', date_str):
        # Ressemble à une date mais format non reconnu, utiliser une date par défaut sécurisée
        return "TO_DATE('2000-01-01', 'YYYY-MM-DD')"
    
    # Ce n'est pas une date, retourner SYSDATE par sécurité
    return "SYSDATE"
